<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>p105 API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>p105</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
from typing import Tuple
from typing import List

# I-A


def matrix_multiplication(m_1: np.ndarray, m_2: np.ndarray) -&gt; np.ndarray:

    # Se obtienen las dimensiones de cada matriz
    shape_m_1 = np.shape(m_1)
    shape_m_2 = np.shape(m_2)
    # Si son incompatibles, devuelve None
    if shape_m_1[1] != shape_m_2[0]:
        return None

    # la matriz resultante tendra las filas de m1 y columnas de m2
    m_r: np.ndarray = np.empty((shape_m_1[0], shape_m_2[1]))
    # Si son compatibles, se multiplican y se devuelve la matriz resultante

    # m_1 -&gt; (i,x) m_2 -&gt; (x,z)
    # bucle de filas m_1
    for i in range(shape_m_1[0]):
        # bucle de columnas m_2
        for j in range(shape_m_2[1]):
            num = 0
            # bucle de sumas y multiplicaciones
            for x in range(shape_m_1[1]):
                # se multiplica cada numero correspondiente
                # de la fila de m_1 y la columna de m_2
                num += m_1[i, x]*m_2[x, j]

            # se multiplican ambos valores
            m_r[i, j] = num

    return m_r


# I-B
def rec_bb(t: List, first: int, last: int, key: int) -&gt; int:
    # m es la parte media de la lista (primero + ultimo)/2

    m = int((first+last)/2)
    # si el elemento del medio es mayor que el numero a buscar
    if t[m] &gt; key:
        # se cambia el ultimo por el mediano menos 1
        # y se llama de nuevo a la funcion
        rec_bb(t, first, m-1, key)
    # si el elemento del medio es menor que el numero a buscar
    elif t[m] &lt; key:
        # se cambia el primero por el mediano mas 1
        # y se llama de nuevo a la funcion
        rec_bb(t, m+1, last, key)
    # si es igual se devuelve m
    elif t[m] == key:
        return m

    # si el primero y el segundo son iguales
    elif first == last:
        # returna None
        return None


def bb(t: List, first: int, last: int, key: int) -&gt; int:
    # m es la parte media de la lista (primero + ultimo)/2
    m = int((first+last)/2)

    # mientras el elemento del medio sea distinto a la key
    while t[m] != key:

        # si el elemento del medio es mayor que el numero a buscar
        if t[m] &gt; key:
            # se cambia el ultimo por el mediano menos 1
            last = m-1
        # si el elemento del medio es menor que el numero a buscar
        elif t[m] &lt; key:
            # se cambia el primero por el mediano mas 1
            first = m+1
        # si es igual se devuelve m
        elif t[m] == key:
            return m
        # si no se ha devuelto se calcula de nuevo el mediano
        m = int((first+last)/2)

    # si el primero y el segundo son iguales
    if first == last:
        return None

# I-C


def matrix_multiplication_dot(m_1: np.ndarray, m_2: np.ndarray) -&gt; np.ndarray:

    # Se obtienen las dimensiones de cada matriz
    shape_m_1 = np.shape(m_1)
    shape_m_2 = np.shape(m_2)

    # Si son incompatibles, devuelve None
    if shape_m_1[1] != shape_m_2[0]:
        return None

    # la matriz resultante tendra las filas de m1 y columnas de m2
    m_r: np.ndarray = np.empty((shape_m_1[0], shape_m_2[1]))
    # Si son compatibles, se multiplican y se devuelve la matriz resultante
    # con np.dot :
    m_r: np.ndarray = m_1.dot(m_2)

    return m_r

# II-A


def min_heapify(h: np.ndarray, i: int):
    tam = len(h) - 1

    # control de errores
    if i &lt; 0 or i &gt; tam:
        return None

    # dato hijo izquierdo
    left = 2 * i + 1

    # dato hijo derecho
    right = 2 * i + 2

    while left &lt;= tam:
        # se toma como minimo inicial el elemento
        # en la posicion del indice de la funcion
        minimum = i

        # se comparan los elementos de la izquierda y
        # el del indice introducido en la funcion
        # si el introducido es mas grande que el izquierdo
        if h[i] &gt; h[left]:
            # el izquierdo pasa a ser el minimo
            minimum = left

        # si el derecho es menor que el introducido y
        # que el minimo o el derecho mayor o igual al tama√±o
        if right &lt;= tam and h[i] &gt; h[right] and h[right] &lt; h[minimum]:
            # el derecho pasa a ser el minimo
            minimum = right

        # en caso de que sea mayor que el introducido
        if minimum &gt; i:
            # se hace swap entre el elemento introducido y el minimo
            h[i], h[minimum] = h[minimum], h[i]
            # y el introducido sera el minimo
            i = minimum
        # en otro caso para
        else:
            break


def insert_min_heap(h: np.ndarray, k: int) -&gt; np.ndarray:

    # control de errores
    if h is None:
        return np.array([k])

    i = len(h)
    # se a√±ade al final de la array
    h = np.append(h, k)

    # mientras la i se mayor que 0 y
    # el padre es mayor que el elemento en i
    while i &gt; 0 and h[(i-1)//2] &gt; h[i]:
        # se swapean el elemento i y su padre
        h[i], h[(i-1)//2] = h[(i-1)//2], h[i]
        # y se continua la ejecuccion por el
        i = (i-1)//2
    return h


def create_min_heap(h: np.ndarray):

    # control de errores
    if h is None:
        return None

    # bucle inverso desde el padre
    for node in range((len(h) - 1) // 2, -1, -1):
        # se llama a la funcion min_heapyfi por cada iteracion
        min_heapify(h, node)

    return h


def min_heap_extract(h: np.ndarray) -&gt; Tuple[int, np.ndarray]:

    tam = len(h)

    # control de errores
    if tam == 0:
        return list()

    # el elemento raiz sera el primero
    root = h[0]

    # aux es el ultimo elemento de la lista
    aux = int(h[tam-1])
    for i in range(tam-1, 0, -1):
        # aux2 pasa a ser el penultimo elemento de la list
        aux2 = int(h[i-1])
        # se guarda el valor de aux en el penultimo lugar
        h[i-1] = aux
        # y aux pasara a ser aux 2
        aux = int(aux2)

        # de esta manera en la siguiente iteracion aux sera el
        # elemento que va a ser sustituido

    # create min heap para que pase a ser heap
    # y h[:-1] para reducir el tama√±o de la array

    return root, create_min_heap(h[:-1])

# II-B


def pq_ini():
    # se crea una array de numpy de tipo 0 y se devuelve
    q = np.ndarray(shape=0)
    return q


def pq_insert(h: np.ndarray, k: int) -&gt; np.ndarray:
    # se inserta llamando a insert_min_heap
    return insert_min_heap(h, k)


def pq_remove(h: np.ndarray) -&gt; Tuple[int, np.ndarray]:
    # se elimina llamando a min_heap_extract
    return min_heap_extract(h)


def min_heap_sort(h: np.ndarray) -&gt; np.ndarray:

    # se crea un min heap y una lista de retorno
    h = create_min_heap(h)
    ret = list()

    # mientras la longitud sea mayor que 0
    while len(h) &gt; 0:
        # se va extrayendo la raiz (numero mas peque√±o)
        root, h = min_heap_extract(h)
        # y se va a√±adiendo a la lista de retorno
        ret.append(root)

    return np.array(ret)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="p105.bb"><code class="name flex">
<span>def <span class="ident">bb</span></span>(<span>t:¬†List, first:¬†int, last:¬†int, key:¬†int) ‚Äë>¬†int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bb(t: List, first: int, last: int, key: int) -&gt; int:
    # m es la parte media de la lista (primero + ultimo)/2
    m = int((first+last)/2)

    # mientras el elemento del medio sea distinto a la key
    while t[m] != key:

        # si el elemento del medio es mayor que el numero a buscar
        if t[m] &gt; key:
            # se cambia el ultimo por el mediano menos 1
            last = m-1
        # si el elemento del medio es menor que el numero a buscar
        elif t[m] &lt; key:
            # se cambia el primero por el mediano mas 1
            first = m+1
        # si es igual se devuelve m
        elif t[m] == key:
            return m
        # si no se ha devuelto se calcula de nuevo el mediano
        m = int((first+last)/2)

    # si el primero y el segundo son iguales
    if first == last:
        return None</code></pre>
</details>
</dd>
<dt id="p105.create_min_heap"><code class="name flex">
<span>def <span class="ident">create_min_heap</span></span>(<span>h:¬†numpy.ndarray)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_min_heap(h: np.ndarray):

    # control de errores
    if h is None:
        return None

    # bucle inverso desde el padre
    for node in range((len(h) - 1) // 2, -1, -1):
        # se llama a la funcion min_heapyfi por cada iteracion
        min_heapify(h, node)

    return h</code></pre>
</details>
</dd>
<dt id="p105.insert_min_heap"><code class="name flex">
<span>def <span class="ident">insert_min_heap</span></span>(<span>h:¬†numpy.ndarray, k:¬†int) ‚Äë>¬†numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_min_heap(h: np.ndarray, k: int) -&gt; np.ndarray:

    # control de errores
    if h is None:
        return np.array([k])

    i = len(h)
    # se a√±ade al final de la array
    h = np.append(h, k)

    # mientras la i se mayor que 0 y
    # el padre es mayor que el elemento en i
    while i &gt; 0 and h[(i-1)//2] &gt; h[i]:
        # se swapean el elemento i y su padre
        h[i], h[(i-1)//2] = h[(i-1)//2], h[i]
        # y se continua la ejecuccion por el
        i = (i-1)//2
    return h</code></pre>
</details>
</dd>
<dt id="p105.matrix_multiplication"><code class="name flex">
<span>def <span class="ident">matrix_multiplication</span></span>(<span>m_1:¬†numpy.ndarray, m_2:¬†numpy.ndarray) ‚Äë>¬†numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def matrix_multiplication(m_1: np.ndarray, m_2: np.ndarray) -&gt; np.ndarray:

    # Se obtienen las dimensiones de cada matriz
    shape_m_1 = np.shape(m_1)
    shape_m_2 = np.shape(m_2)
    # Si son incompatibles, devuelve None
    if shape_m_1[1] != shape_m_2[0]:
        return None

    # la matriz resultante tendra las filas de m1 y columnas de m2
    m_r: np.ndarray = np.empty((shape_m_1[0], shape_m_2[1]))
    # Si son compatibles, se multiplican y se devuelve la matriz resultante

    # m_1 -&gt; (i,x) m_2 -&gt; (x,z)
    # bucle de filas m_1
    for i in range(shape_m_1[0]):
        # bucle de columnas m_2
        for j in range(shape_m_2[1]):
            num = 0
            # bucle de sumas y multiplicaciones
            for x in range(shape_m_1[1]):
                # se multiplica cada numero correspondiente
                # de la fila de m_1 y la columna de m_2
                num += m_1[i, x]*m_2[x, j]

            # se multiplican ambos valores
            m_r[i, j] = num

    return m_r</code></pre>
</details>
</dd>
<dt id="p105.matrix_multiplication_dot"><code class="name flex">
<span>def <span class="ident">matrix_multiplication_dot</span></span>(<span>m_1:¬†numpy.ndarray, m_2:¬†numpy.ndarray) ‚Äë>¬†numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def matrix_multiplication_dot(m_1: np.ndarray, m_2: np.ndarray) -&gt; np.ndarray:

    # Se obtienen las dimensiones de cada matriz
    shape_m_1 = np.shape(m_1)
    shape_m_2 = np.shape(m_2)

    # Si son incompatibles, devuelve None
    if shape_m_1[1] != shape_m_2[0]:
        return None

    # la matriz resultante tendra las filas de m1 y columnas de m2
    m_r: np.ndarray = np.empty((shape_m_1[0], shape_m_2[1]))
    # Si son compatibles, se multiplican y se devuelve la matriz resultante
    # con np.dot :
    m_r: np.ndarray = m_1.dot(m_2)

    return m_r</code></pre>
</details>
</dd>
<dt id="p105.min_heap_extract"><code class="name flex">
<span>def <span class="ident">min_heap_extract</span></span>(<span>h:¬†numpy.ndarray) ‚Äë>¬†Tuple[int,¬†numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def min_heap_extract(h: np.ndarray) -&gt; Tuple[int, np.ndarray]:

    tam = len(h)

    # control de errores
    if tam == 0:
        return list()

    # el elemento raiz sera el primero
    root = h[0]

    # aux es el ultimo elemento de la lista
    aux = int(h[tam-1])
    for i in range(tam-1, 0, -1):
        # aux2 pasa a ser el penultimo elemento de la list
        aux2 = int(h[i-1])
        # se guarda el valor de aux en el penultimo lugar
        h[i-1] = aux
        # y aux pasara a ser aux 2
        aux = int(aux2)

        # de esta manera en la siguiente iteracion aux sera el
        # elemento que va a ser sustituido

    # create min heap para que pase a ser heap
    # y h[:-1] para reducir el tama√±o de la array

    return root, create_min_heap(h[:-1])</code></pre>
</details>
</dd>
<dt id="p105.min_heap_sort"><code class="name flex">
<span>def <span class="ident">min_heap_sort</span></span>(<span>h:¬†numpy.ndarray) ‚Äë>¬†numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def min_heap_sort(h: np.ndarray) -&gt; np.ndarray:

    # se crea un min heap y una lista de retorno
    h = create_min_heap(h)
    ret = list()

    # mientras la longitud sea mayor que 0
    while len(h) &gt; 0:
        # se va extrayendo la raiz (numero mas peque√±o)
        root, h = min_heap_extract(h)
        # y se va a√±adiendo a la lista de retorno
        ret.append(root)

    return np.array(ret)</code></pre>
</details>
</dd>
<dt id="p105.min_heapify"><code class="name flex">
<span>def <span class="ident">min_heapify</span></span>(<span>h:¬†numpy.ndarray, i:¬†int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def min_heapify(h: np.ndarray, i: int):
    tam = len(h) - 1

    # control de errores
    if i &lt; 0 or i &gt; tam:
        return None

    # dato hijo izquierdo
    left = 2 * i + 1

    # dato hijo derecho
    right = 2 * i + 2

    while left &lt;= tam:
        # se toma como minimo inicial el elemento
        # en la posicion del indice de la funcion
        minimum = i

        # se comparan los elementos de la izquierda y
        # el del indice introducido en la funcion
        # si el introducido es mas grande que el izquierdo
        if h[i] &gt; h[left]:
            # el izquierdo pasa a ser el minimo
            minimum = left

        # si el derecho es menor que el introducido y
        # que el minimo o el derecho mayor o igual al tama√±o
        if right &lt;= tam and h[i] &gt; h[right] and h[right] &lt; h[minimum]:
            # el derecho pasa a ser el minimo
            minimum = right

        # en caso de que sea mayor que el introducido
        if minimum &gt; i:
            # se hace swap entre el elemento introducido y el minimo
            h[i], h[minimum] = h[minimum], h[i]
            # y el introducido sera el minimo
            i = minimum
        # en otro caso para
        else:
            break</code></pre>
</details>
</dd>
<dt id="p105.pq_ini"><code class="name flex">
<span>def <span class="ident">pq_ini</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pq_ini():
    # se crea una array de numpy de tipo 0 y se devuelve
    q = np.ndarray(shape=0)
    return q</code></pre>
</details>
</dd>
<dt id="p105.pq_insert"><code class="name flex">
<span>def <span class="ident">pq_insert</span></span>(<span>h:¬†numpy.ndarray, k:¬†int) ‚Äë>¬†numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pq_insert(h: np.ndarray, k: int) -&gt; np.ndarray:
    # se inserta llamando a insert_min_heap
    return insert_min_heap(h, k)</code></pre>
</details>
</dd>
<dt id="p105.pq_remove"><code class="name flex">
<span>def <span class="ident">pq_remove</span></span>(<span>h:¬†numpy.ndarray) ‚Äë>¬†Tuple[int,¬†numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pq_remove(h: np.ndarray) -&gt; Tuple[int, np.ndarray]:
    # se elimina llamando a min_heap_extract
    return min_heap_extract(h)</code></pre>
</details>
</dd>
<dt id="p105.rec_bb"><code class="name flex">
<span>def <span class="ident">rec_bb</span></span>(<span>t:¬†List, first:¬†int, last:¬†int, key:¬†int) ‚Äë>¬†int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rec_bb(t: List, first: int, last: int, key: int) -&gt; int:
    # m es la parte media de la lista (primero + ultimo)/2

    m = int((first+last)/2)
    # si el elemento del medio es mayor que el numero a buscar
    if t[m] &gt; key:
        # se cambia el ultimo por el mediano menos 1
        # y se llama de nuevo a la funcion
        rec_bb(t, first, m-1, key)
    # si el elemento del medio es menor que el numero a buscar
    elif t[m] &lt; key:
        # se cambia el primero por el mediano mas 1
        # y se llama de nuevo a la funcion
        rec_bb(t, m+1, last, key)
    # si es igual se devuelve m
    elif t[m] == key:
        return m

    # si el primero y el segundo son iguales
    elif first == last:
        # returna None
        return None</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="p105.bb" href="#p105.bb">bb</a></code></li>
<li><code><a title="p105.create_min_heap" href="#p105.create_min_heap">create_min_heap</a></code></li>
<li><code><a title="p105.insert_min_heap" href="#p105.insert_min_heap">insert_min_heap</a></code></li>
<li><code><a title="p105.matrix_multiplication" href="#p105.matrix_multiplication">matrix_multiplication</a></code></li>
<li><code><a title="p105.matrix_multiplication_dot" href="#p105.matrix_multiplication_dot">matrix_multiplication_dot</a></code></li>
<li><code><a title="p105.min_heap_extract" href="#p105.min_heap_extract">min_heap_extract</a></code></li>
<li><code><a title="p105.min_heap_sort" href="#p105.min_heap_sort">min_heap_sort</a></code></li>
<li><code><a title="p105.min_heapify" href="#p105.min_heapify">min_heapify</a></code></li>
<li><code><a title="p105.pq_ini" href="#p105.pq_ini">pq_ini</a></code></li>
<li><code><a title="p105.pq_insert" href="#p105.pq_insert">pq_insert</a></code></li>
<li><code><a title="p105.pq_remove" href="#p105.pq_remove">pq_remove</a></code></li>
<li><code><a title="p105.rec_bb" href="#p105.rec_bb">rec_bb</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>